! --------------------------------------------------------------------------------------------------
! This program calculates the LTO phonon decay rate based on the results from d3.x,
! which provides the anharmonic coeffients for a set of q-points, findpath.x, which gives
! the decay paths within error tolerence. It also needs DOS as input. Eventually, it output
! decay rates for each decay path and the total decay rate.
! It ONLY takes a non-offset q-grid or mesh.
! 
! Hongze Xia, 2014-04-02, sunny afternoon.
! Changlog:
! Added read from QE band file, 2014-04-03
! Added read q-weight from decaypath.txt, 2014-04-04
! Complete readdos, 2014-04-04
! Simple interpolation on DOS, 2014-04-04
! fixed polar, the product of magnitudes of phonon modes, 2014-04-05
! freq * 2Pi = omega, 2014-04-06
! used real q-weight instead of number of folds, 2014-04-06
! fixed polar, it turned out that this should be complex number instead of amplititude.
! This is a torturing mistake in Derbernardi's thesis, 2014-04-22
! Add fake-delta function, count mirror process, 2014-04-27
! --------------------------------------------------------------------------------------------------
! Input cards: namelist &input
! nat : number of basis in the unit cell. ***MUST BE SET***
! fldp : decay path file. Default "decaypath.txt". Format for this file is illustrated below:
!       nksp !  number of q-point in the decay path in 2pin/alat
!   j1 j2 nks_1
!   i1 i2 nks_2
!   ........
! fldos : DOS file generated by matdyn.x . Default "matdyn.dos".
! flphi : corresponding anharmonic coefficients for the path. Default "phi.raw". 
!           The array has this shape: phi(3,3,3,nat,nat,nat,nksp).
! j0 : the target mode whose decay rate is interested. ***MUST BE SET***
! flfreq : freq for the mesh. Default "freq.txt". QE band file.
!             It contains nks: number of q-point in the mesh. and nbnd
! fleig:    eig for the mesh. Default "zall.raw". z(3*nat,3*nat,nks).
! At the end of the input namelist, you append a mass array:
! ATOMIC MASS
! m1
! m2
! m3
! ....

MODULE INC   
    ! Some physical constants
    real(8), parameter :: pi = 3.1415927
    real(8), parameter :: hbar = 1.054571726d-34  ! in S.I. Js
    real(8), parameter :: hbarev = 6.58211928d-16  ! in ev.s
    real(8), parameter :: hartree = 27.211                ! 1Ha in eV
    real(8), parameter :: kb = 8.6173325e-5            ! in eV/K
    real(8), parameter :: temp = 300                        ! in Kelvin
    real(8), parameter :: kbt = kb*temp                   ! in eV
    real(8), parameter :: cm2ev = 1.0/8.065*1e-3   ! 1 meV = 8.065 cm-1
    real(8), parameter :: emass = 9.10938291e-31 ! in kg
    real(8), parameter :: pmass = 1.67262178e-27 ! in kg
    real(8), parameter :: s2cm = 1.0e-12*33.333    ! s-1 to cm-1
    real(8), parameter :: ryd2ev = 2.0*hartree         ! Rydberg to Hartree
    real(8), parameter :: ev2j = 1.602176565d-19   ! eV to J
    real(8), parameter :: bohr = 0.5291772d-10      ! in m
    real(8), parameter :: sigma = 1.6                       ! trust radius cm-1
!     real(8), parameter :: 
    CONTAINS
    SUBROUTINE readmass(nat,mass)
        ! input parameters
        integer, intent(in) :: nat
        real(8), allocatable, intent(out) :: mass(:)
        ! local
        CHARACTER(LEN=20) :: card,n1,n2
        integer :: i
        !
        ALLOCATE( mass(nat) )
        ! read mass
        read(5,*) n1,n2
        card = TRIM(n1)//' '//TRIM(n2)
        if ( TRIM(card)=="ATOMIC MASS" .or. TRIM(card)=="atomic mass") then
            do i = 1,nat
                read(5,*) mass(i)
            end do
        else
                print *,"Error reading mass"
                stop 1
        endif
    END SUBROUTINE readmass
    
    subroutine readdos(fldos,dos)
        ! input parameters
        CHARACTER(LEN=256), intent(in) :: fldos
        real(8), allocatable :: dos(:,:)
        ! local
        integer :: i,j,n,status
        CHARACTER(LEN=256) :: cmd
        ! output total number of lines in the fldos
        cmd = "wc -l "//TRIM(fldos)//" > ndos"
        CALL system(TRIM(cmd),status)
        if ( status .ne. 0 ) then
            print *,"Error in reading DOS"
            stop 2
        end if
        open(unit=1001, file="ndos", action="read")
        read(1001,*) n
        close(1001)
        CALL system("rm -rf ndos")
        !
        ALLOCATE( dos(2,n) )
        open(unit=1002, file=TRIM(fldos), action="read")
        do i = 1,n
            read(1002,*) (dos(j,i),j=1,2)
        end do
        close(1002)
    end subroutine readdos
    
    subroutine readdp(fldp,nksp,dp,qwgt)
        ! input parameters
        CHARACTER(LEN=256), intent(in) :: fldp
        integer, intent(out) :: nksp
        integer, allocatable, intent(out) :: dp(:,:)
        real(8), allocatable, intent(out) :: qwgt(:)
        ! local
        integer :: i,j
        !
        ! read from file
        open(unit=6969, file=TRIM(fldp), action="read")
        read(6969,*) nksp
        ALLOCATE( dp(3,nksp),qwgt(nksp) )
        do i = 1,nksp
            read(6969,*) (dp(j,i),j=1,3),qwgt(i)
        end do
        close(6969)
    end subroutine readdp
    
    Function bos_ein(e)
        ! the Bose-Einstein distribution
        real(8) :: bos_ein
        real(8) :: e             ! phonon energy in eV
        bos_ein = 1.0 / (exp(e/kbt) - 1)
    END Function bos_ein
    
    subroutine readband(flband,eval,qvec,nbnd,nks)
        CHARACTER(LEN=256), intent(in) :: flband
        REAL(8), DIMENSION(:,:), ALLOCATABLE :: eval, qvec
        integer :: nbnd,nks
        ! local
        integer :: i,j
        NAMELIST /plot/ nbnd,nks
        open(unit=1001,file=TRIM(flband),action='read')
        read(1001,nml=plot)
        ALLOCATE( eval(nbnd,nks),qvec(3,nks) )
        do i = 1,nks
            read(1001,*) (qvec(j,i),j=1,3)
            read(1001,*) (eval(j,i),j=1,nbnd)
        end do
        close(1001)
    end subroutine readband
    
    Function whatdos(dos,e)
        ! this func returns an interpolated value as DOS(e)
        ! input parameters
        real(8) :: dos(:,:),e,whatdos
        ! local
        integer :: i,j,n
        !
        n = size( dos(1,:) )
        if ( e .lt. dos(1,1) .or. e .gt. dos(1,n) ) then
            whatdos = 0.0
        else
            do i = 1,n-1
                if ( e .le. dos(1,i+1) .and. e .ge. dos(1,i) ) &
                    whatdos = (dos(2,i+1)-dos(2,i))/(dos(1,i+1)-dos(1,i))*&
                                        (e-dos(1,i)) + dos(2,i)
            end do
        endif
    END Function whatdos

    subroutine readphi(phi,nq)
        ! input parameters
        complex (8) :: phi (:,:,:,:,:,:,:)
        integer :: nq ! number of q-points in that folder
        ! local
        CHARACTER(LEN=256) :: flname
        integer :: n
        
        do n = 1,nq
            write(flname,9002) n
            open(unit=6969, file=TRIM(flname), action="read",&
                form='unformatted')
    !       print *,TRIM(flname)
            read(6969) phi(:,:,:,:,:,:,n)
            close(6969)
        end do
        
    9002 format("phi/phi.",i0.0,".raw")
    end subroutine readphi
    
    Function fakedelta(x0,x)
        ! replace Delta function with e^(-x^2)
        ! x0,x in cm-1
        real(8) :: fakedelta
        real(8) :: x0,x
        fakedelta = exp(-((x0-x)/sigma)**2 )
    END Function fakedelta

END MODULE INC

PROGRAM DR
    USE INC
    IMPLICIT NONE
    ! variables in the input namelist
    integer :: nat,j0,nks,nbnd
    CHARACTER(LEN=256) :: fldp,fldos,flphi,flfreq,fleig
    ! number of q-point in the decay path in 2pin/alat
    integer :: nksp
    integer, allocatable :: dp(:,:)
    real(8), allocatable :: freq(:,:),dos(:,:),qvec(:,:),mass(:),qwgt(:)
    complex (8), allocatable :: phi (:,:,:,:,:,:,:),z(:,:,:)
    ! trivial indices
    integer :: i,j,j1,j2,q,s,s1,s2,a,b,y
    real(8) :: prefactor,w0,sum_g,nj1,nj2,dr_q,g,polar
    complex(8) :: sum_v,tmp_v
    NAMELIST /input/ nat,j0,fldp,fldos,flphi,flfreq,fleig
    !
    ! set default values
    fldp = "decaypath.txt"
    fldos = "matdyn.dos"
    flphi = "phi.raw"
    flfreq = "freq.txt"
    fleig = "zall.raw"
    !
    ! read the namelist
    READ(5,nml=input)
    CALL readmass(nat,mass)
    CALL readband(flfreq,freq,qvec,nbnd,nks)
    CALL readdp(fldp,nksp,dp,qwgt)
    CALL readdos(fldos,dos)
    !
    ALLOCATE( phi(3,3,3,nat,nat,nat,nksp) )
    CALL readphi( phi,nksp )
    !
    ALLOCATE( z(3*nat,3*nat,nks) )
    !
    ! load data from files
!     open(unit=6969, file=TRIM(flphi), action="read", form='unformatted')
!     read(6969) phi
!     close(6969)
    open(unit=6969, file=TRIM(fleig), action="read", form='unformatted')
    read(6969) z
    close(6969)
    !
    ! Unit conversion
    mass = mass*pmass
    phi = phi*ryd2ev*ev2j/bohr**3
    dos(2,:) = dos(2,:)*s2cm/(2.*pi)
    ! End of initiation
    ! Start of the calculation
    w0 = freq(j0,1)
    prefactor = pi*hbar/(16.0*w0)*(s2cm)**3/(2.*pi)**3
    sum_g = 0.0
    !
    do i = 1,nksp
        ! some indices
        j1 = dp(1,i); j2 = dp(2,i); q = dp(3,i)
        ! Bose-Einstein occupantion number
        nj1 = bos_ein(freq(j1,q)*cm2ev); nj2 = bos_ein(freq(j2,q)*cm2ev)
        ! joint DOS
        g = SQRT( whatdos(dos,freq(j1,q))*whatdos(dos,freq(j2,q)) )
        !
        sum_v = (0.0,0.0)
        !
        do s = 1,nat
            do s1 = 1,nat
                do s2 = 1,nat
                    !
                    tmp_v = (0.0,0.0)
                    do a = 1,3
                        do b = 1,3
                            do y = 1,3
                                polar = z(s*3+a-3,j0,1)*z(s1*3+b-3,j1,q)*z(s2*3+y-3,j2,q)
!                                 if ( i .eq. 1 ) print *,"polar=",polar ! test
!                                 print *,"phi=",phi(a,b,y,s,s1,s2,i)
                                tmp_v = tmp_v+phi(a,b,y,s,s1,s2,i)*polar
                            end do
                        end do
                    end do
                    !
!                     print *,"tmp_v=",tmp_v
                    sum_v = sum_v+tmp_v*SQRT( 1.0/(mass(s)*mass(s1)*mass(s2)) )
                    !
                end do
            end do
        end do
!         print *,"sum_v=",ABS(sum_v)*ABS(sum_v)
        ! q-weight appended, g added, delta, 2 counts j2,j1 pairs
        dr_q = 2.0*ABS(sum_v)*ABS(sum_v)*(nj1+nj2+1)/freq(j1,q)/freq(j2,q) &
                    *prefactor*qwgt(i)*g*fakedelta(w0,freq(j1,q)+freq(j2,q))
        sum_g = sum_g+dr_q
        !
        write(*,9000) qvec(:,q),dr_q,2.*dr_q*s2cm/2./pi
        !
    end do
    !
    write(*,9001) sum_g,2.*sum_g*s2cm/2./pi
    !
    DEALLOCATE( freq,qvec,z,phi,dp,qwgt,mass)
    
    9000 format("Decay rate at ",'(',3(f8.4,1x),') : ', e10.4," s-1 or",f8.4," cm-1")
    9001 format("Total decay rate at Gamma: ",e10.4," s-1 or",f8.4," cm-1")
END PROGRAM DR
