#!/usr/bin/python
from subprocess import call


YAMBO_PATH = r'/opt/yambo/yambo'

PLOT = True
RUN_YAMBO = False
# "STD" for 'EXX', 'BndsRn', 'NGsBlk', 'Gbnd' convergence
# "GVEC" for 'MaxGvecs'
TASK = "GVEC"

INPUT_PARAMS = dict(
    # parallel settings
    ncores = 8,
    xq = 1, xk = 8, xc = 1, xv = 1,
    seq = 1, seqp = 8, seb = 1,
    # convergence test, initial values
    EXX = 7, # Ry
    BndsRn = 50,
    NGsBlk = 5, # Ry
    Gbnd = 50
)

# range of testing
# for TASK == "STD"
EXXRange = [10, 15, 20, 25, 30, 35, 40]
BndsRnRange = [30, 40, 50, 60, 70, 100]
NGsBlkRange = [1, 3, 6, 7, 10, 15, 20]
GbndRange = [50, 60, 70, 100]
EnableRange = [False, False, False, True] # with respect to the four ranges above
# for TASK == "GVEC"
GvecRange = [1./8., 1./4., 1./2., 3./4., 1]

# check parallel settings
assert INPUT_PARAMS["ncores"] == INPUT_PARAMS["xq"] * \
    INPUT_PARAMS["xk"] *INPUT_PARAMS["xc"] * INPUT_PARAMS["xv"], \
    "check parallel settings"
assert INPUT_PARAMS["ncores"] == INPUT_PARAMS["seq"] * \
    INPUT_PARAMS["seqp"] *INPUT_PARAMS["seb"], \
    "check parallel settings"

# this file can be generated by
# yambo -V par -d -k hartree -g n -p p -F yambo.in
YAMBO_INPUT_FILE = """# for PPA convergence test only
em1d                         # [R Xd] Dynamical Inverse Dielectric Matrix
gw0                          # [R GW] GoWo Quasiparticle energy levels
ppa                          # [R Xp] Plasmon Pole Approximation
HF_and_locXC                 # [R XX] Hartree-Fock Self-energy and Vxc
NLogCPUs=0                   # [PARALLEL] Live-timing CPU`s (0 for all)
X_all_q_CPU= "{xq} {xk} {xc} {xv}"              # [PARALLEL] CPUs for each role
X_all_q_ROLEs= "q k c v"            # [PARALLEL] CPUs roles (q,k,c,v)
X_all_q_nCPU_invert=0        # [PARALLEL] CPUs for matrix inversion
SE_CPU= "{seq} {seqp} {seb}"                   # [PARALLEL] CPUs for each role
SE_ROLEs= "q qp b"                 # [PARALLEL] CPUs roles (q,qp,b)
EXXRLvcs=  {EXX}           Ry    # [XX] Exchange RL components
Chimod= "hartree"            # [X] IP/Hartree/ALDA/LRC/BSfxc
% BndsRnXp
   1 |  {BndsRn} |                 # [Xp] Polarization function bands
%
NGsBlkXp=  {NGsBlk}           Ry    # [Xp] Response block size
% LongDrXp
 1.000000 | 0.000000 | 0.000000 |        # [Xp] [cc] Electric Field
%
PPAPntXp= 27.21138     eV    # [Xp] PPA imaginary energy
% GbndRnge
   1 |  {Gbnd} |                 # [GW] G[W] bands range
%
GDamping=  0.10000     eV    # [GW] G[W] damping
dScStep=  0.10000      eV    # [GW] Energy step to evaluate Z factors
GTermKind= "none"            # [GW] GW terminator ("none","BG" Bruneval-Gonze,"BRS" Berger-Reining-Sottile)
DysSolver= "n"               # [GW] Dyson Equation solver ("n","s","g")
%QPkrange                    # [GW] QP generalized Kpoint/Band indices
  1|  8|  1| 54|             # [HX] keep the last number the same as nbnd in the band structure calculation
%
"""

YAMBO_MAXGVEC = """
MaxGvecs= {MaxGvecs}       RL    # [INI] Max number of G-vectors planned to use
"""

def write_yambo_in(yambo, path="yambo.in"):
    with open(path, "w") as f:
        f.write(yambo)

def max_gvec():
    call(["rm", "-rf", "r_setup*"])
    write_yambo_in("setup")
    retcode = call([YAMBO_PATH, ">&", "/dev/null"])
    if retcode:
        print "An error has occurred!"
    with open("r_setup") as f:
        for line in f:
            # skip comments and other stuff
            if line[:11] == '  G-vectors':
                return int(line.split()[-1])
    raise IOError("r_setup does not exist!")
    
if __name__ == '__main__':
    if RUN_YAMBO:
        print "Convergence test begins:"
    if PLOT:
        from plot_conv import plot
        import matplotlib.pylab as plt

    if TASK == "STD":
        TASKID = "EXX{EXX}Ry_BndsRn{BndsRn}_NGsBlk{NGsBlk}Ry_Gbnd{Gbnd}"
        descriptions = ["==>> Exchange component EXXRLvcs",
                        "==>> Polarization function bands BndsRn",
                        "==>> Response block size NGsBlk",
                        "==>> W bands range Gbnd"
        ]
        if PLOT:
            fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(20,10))
            fig.subplots_adjust(hspace=.3)
            axes = [ax for row in axes for ax in row]
    
        params = ['EXX', 'BndsRn', 'NGsBlk', 'Gbnd']
        ranges = [EXXRange, BndsRnRange, NGsBlkRange, GbndRange]
    
        for i in range(4):
            taskids = []
            if RUN_YAMBO and EnableRange[i]:
                print descriptions[i]
            for var in ranges[i]:
                inputs = INPUT_PARAMS.copy()
                inputs[params[i]] = var
                taskid = TASKID.format(**inputs)
                taskids.append(taskid)
                if RUN_YAMBO and EnableRange[i]:
                    print "---> %s = %d" % (params[i], var)
                    yambo = YAMBO_INPUT_FILE.format(**inputs)
                    write_yambo_in(yambo)
                    retcode = call(["mpirun", "-np", str(inputs['ncores']), 
                        YAMBO_PATH, "-J", taskid])
                    if retcode:
                        print "An error has occurred."
            if PLOT:
                plot(axes[i], taskids, params[i])
                
    elif TASK == "GVEC":
        if RUN_YAMBO:
            maxGvec = max_gvec()
            discription = "==>> G-Vector component MaxGvecs"
            gvec_range = [int(g*maxGvec) for g in GvecRange]
            print "---> testing ", gvec_range
            for var in gvec_range:
                print "---> MaxGVec = %d" % var
                yambo_maxgvec = YAMBO_MAXGVEC.format(MaxGvecs=var)
                yambo = YAMBO_INPUT_FILE.format(**INPUT_PARAMS) + yambo_maxgvec
                write_yambo_in(yambo)
                taskid = "GVEC%d" % var
                retcode = call(["mpirun", "-np", str(INPUT_PARAMS['ncores']), 
                    YAMBO_PATH, "-J", taskid])
                if retcode:
                    print "An error has occurred!"
                
        if PLOT:
            fig, ax = plt.subplots(figsize=(10,5))
            import glob
            files = glob.glob("o-GVEC*")
            taskids = [fl.split("-")[1].split(".")[0] for fl in files]
            plot(ax, taskids, "GVEC")
        
    if PLOT:
        plt.savefig('conv_test_%s.pdf' % TASK)
        plt.show()
        plt.close()
